extends CharacterBody2D

const tile_size: Vector2 = Vector2(8, 4)
@export var move_speed: float = 30.0
@export var move_delay: float = 0.0
@export var detection_range: float = 100.0

@onready var sprite: AnimatedSprite2D = $AnimatedSprite2D if has_node("AnimatedSprite2D") else null
@onready var hitbox: Area2D = $Hitbox if has_node("Hitbox") else null

var is_moving: bool = false
var target_pos: Vector2
var player: CharacterBody2D
var move_timer: float = 0.0
var current_direction: String = "SE"
var attack_cooldown: float = 0.0
var can_attack: bool = true

func _ready() -> void:
	add_to_group("enemy")
	target_pos = global_position
	# Find the player node
	player = get_tree().get_first_node_in_group("player")
	
	# Connect hitbox signal
	if hitbox:
		hitbox.body_entered.connect(_on_hitbox_body_entered)
	
	# Play initial idle animation
	if sprite:
		sprite.play("Idle_" + current_direction)

func _physics_process(delta: float) -> void:
	if not player:
		return
	
	# Handle attack cooldown
	if not can_attack:
		attack_cooldown -= delta
		if attack_cooldown <= 0:
			can_attack = true
	
	# If moving, interpolate smoothly to target
	if is_moving:
		var direction = (target_pos - global_position).normalized()
		velocity = direction * move_speed
		move_and_slide()
		
		# If we hit something, stop moving
		if get_slide_collision_count() > 0:
			velocity = Vector2.ZERO
			is_moving = false
			target_pos = global_position
			move_timer = move_delay
		elif global_position.distance_to(target_pos) < 0.5:
			global_position = target_pos
			velocity = Vector2.ZERO
			is_moving = false
			move_timer = move_delay
		return
	
	# Wait before next move
	if move_timer > 0:
		move_timer -= delta
		return
	
	# Calculate direction to player
	var direction_to_player = player.global_position - global_position
	var distance_to_player = global_position.distance_to(player.global_position)
	
	# Don't move if player is out of range
	if distance_to_player > detection_range:
		return
	
	# Stop moving if we're adjacent to the player (within half a tile)
	if distance_to_player < 5:
		return
	
	# Check line of sight to player using raycast
	var space_state = get_world_2d().direct_space_state
	var ray_query = PhysicsRayQueryParameters2D.create(global_position, player.global_position)
	ray_query.collision_mask = collision_mask
	ray_query.collide_with_areas = false
	ray_query.collide_with_bodies = true
	ray_query.exclude = [self]
	
	var ray_result = space_state.intersect_ray(ray_query)
	
	# If raycast hit something before reaching player, can't see them
	if ray_result and ray_result.collider != player:
		return
	
	# Determine the best direction based on player position
	var move_offset: Vector2 = Vector2.ZERO
	
	# Choose the diagonal direction that gets closest to player
	if direction_to_player.x > 0 and direction_to_player.y > 0:
		move_offset = Vector2(tile_size.x, tile_size.y)  # SE
	elif direction_to_player.x < 0 and direction_to_player.y < 0:
		move_offset = Vector2(-tile_size.x, -tile_size.y)  # NW
	elif direction_to_player.x < 0 and direction_to_player.y > 0:
		move_offset = Vector2(-tile_size.x, tile_size.y)  # SW
	else:  # x > 0 and y < 0
		move_offset = Vector2(tile_size.x, -tile_size.y)  # NE
	
	# Try primary direction first
	var test_pos = global_position + move_offset
	var query = PhysicsPointQueryParameters2D.new()
	query.position = test_pos
	query.collision_mask = collision_mask
	query.collide_with_areas = false
	var result = space_state.intersect_point(query, 1)
	if result.is_empty():
		# Check if tile is occupied by player
		if player.global_position.distance_to(test_pos) >= 2:
			target_pos = test_pos
			is_moving = true
			
			# Update sprite direction and animation
			if sprite:
				var new_direction = ""
				if move_offset == Vector2(tile_size.x, tile_size.y):
					new_direction = "SE"
				elif move_offset == Vector2(-tile_size.x, -tile_size.y):
					new_direction = "NW"
				elif move_offset == Vector2(-tile_size.x, tile_size.y):
					new_direction = "SW"
				elif move_offset == Vector2(tile_size.x, -tile_size.y):
					new_direction = "NE"
				
				if new_direction != current_direction:
					current_direction = new_direction
					sprite.play("Idle_" + current_direction)
		return
	
	# If blocked, try alternate directions
	var alternate_moves = []
	if abs(direction_to_player.x) > abs(direction_to_player.y):
		# Prefer horizontal movement
		if direction_to_player.x > 0:
			alternate_moves = [
				Vector2(tile_size.x, -tile_size.y),  # NE
				Vector2(tile_size.x, tile_size.y),   # SE
				Vector2(-tile_size.x, -tile_size.y), # NW
				Vector2(-tile_size.x, tile_size.y)   # SW
			]
		else:
			alternate_moves = [
				Vector2(-tile_size.x, tile_size.y),  # SW
				Vector2(-tile_size.x, -tile_size.y), # NW
				Vector2(tile_size.x, tile_size.y),   # SE
				Vector2(tile_size.x, -tile_size.y)   # NE
			]
	else:
		# Prefer vertical movement
		if direction_to_player.y > 0:
			alternate_moves = [
				Vector2(tile_size.x, tile_size.y),   # SE
				Vector2(-tile_size.x, tile_size.y),  # SW
				Vector2(tile_size.x, -tile_size.y),  # NE
				Vector2(-tile_size.x, -tile_size.y)  # NW
			]
		else:
			alternate_moves = [
				Vector2(-tile_size.x, -tile_size.y), # NW
				Vector2(tile_size.x, -tile_size.y),  # NE
				Vector2(-tile_size.x, tile_size.y),  # SW
				Vector2(tile_size.x, tile_size.y)    # SE
			]
	
	# Try each alternate direction
		if result.is_empty():
			target_pos = test_pos
	# Try each alternate direction
	for alt_move in alternate_moves:
		var alt_test_pos = global_position + alt_move
		query.position = alt_test_pos
		result = space_state.intersect_point(query, 1)
		
		if result.is_empty():
			# Check if tile is occupied by player
			if player.global_position.distance_to(alt_test_pos) >= 2:
				target_pos = alt_test_pos
				is_moving = true
				
				# Update sprite direction and animation
				if sprite:
					var new_direction = ""
					if alt_move == Vector2(tile_size.x, tile_size.y):
						new_direction = "SE"
					elif alt_move == Vector2(-tile_size.x, -tile_size.y):
						new_direction = "NW"
					elif alt_move == Vector2(-tile_size.x, tile_size.y):
						new_direction = "SW"
					elif alt_move == Vector2(tile_size.x, -tile_size.y):
						new_direction = "NE"
					
					if new_direction != current_direction:
						current_direction = new_direction
						sprite.play("Idle_" + current_direction)
				return

	# Track stuck time; if not moving enough for several seconds, teleport near player
	var moved_distance = global_position.distance_to(last_position)
	if moved_distance < 0.5:
		stuck_timer += delta
		if stuck_timer >= STUCK_TIME:
			_unstuck_to_player()
	else:
		stuck_timer = 0.0
	last_position = global_position

func _unstuck_to_player() -> void:
	if not player:
		return
	var space_state = get_world_2d().direct_space_state
	var candidate_offsets = [
		Vector2(tile_size.x, tile_size.y),
		Vector2(-tile_size.x, -tile_size.y),
		Vector2(-tile_size.x, tile_size.y),
		Vector2(tile_size.x, -tile_size.y),
		Vector2.ZERO
	]
	var query = PhysicsPointQueryParameters2D.new()
	query.collide_with_areas = false
	query.collision_mask = collision_mask
	for offset in candidate_offsets:
		var test_pos = player.global_position + offset
		query.position = test_pos
		var result = space_state.intersect_point(query, 1)
		var tile_free = result.is_empty()
		var avoids_player = offset == Vector2.ZERO or player.global_position.distance_to(test_pos) >= 2
		if tile_free and avoids_player:
			global_position = test_pos
			target_pos = test_pos
			velocity = Vector2.ZERO
			is_moving = false
			move_timer = move_delay
			stuck_timer = 0.0
			last_position = global_position
			return

func _on_hitbox_body_entered(body: Node2D) -> void:
	print("Hitbox detected: ", body.name)  # Debug line
	if body.is_in_group("player") and can_attack:
		print("Attacking player!")  # Debug line
		# Attack the player
		if body.has_method("take_damage"):
			body.take_damage()
			can_attack = false
			attack_cooldown = 3.0  # 3 second cooldown
